#!/usr/bin/env python

import rospy
import cv2
import numpy as np
import time

from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from crane_msgs.msg import CraneControl

from crane_vision.transformations import trf
from crane_vision.camera import CameraArray
from crane_vision.vision import find_sphere_centers, find_line
from crane_vision.ekf import ekf


# Camera calibration matrices
K2 = np.array([[937, 0, 637.21],
               [0, 937, 381.54],
               [0, 0,   1.0]])

K1 = np.array([[941, 0, 637.21],
               [0, 941, 349.9],
               [0, 0,   1.0]])

K0 = np.array([[942, 0, 623.66],
               [0, 942, 345.69],
               [0, 0,   1.0]])

# Translation vectors between cameras
t_11 = np.array([0, 0, 0])
t_21 = np.array([233.8, 0, 0])
t_31 = np.array([467, 0, 0])
PII = np.eye(3, 4)

# Camera matrices
P0 = np.dot(np.dot(K0, PII), trf(np.eye(3), t_11))
P1 = np.dot(np.dot(K1, PII), trf(np.eye(3), t_21))
P2 = np.dot(np.dot(K2, PII), trf(np.eye(3), t_31))

debug = False

pendulum_pub = rospy.Publisher('pendulum_joint_states', JointState, queue_size=3)

hat_Pk = np.diag([0, 0, 0, 0, 0, 0])
hat_thetak = np.array([0, 0, 0, 0, np.deg2rad(2.5), np.deg2rad(-1.7)])

q1 = np.deg2rad(37.4)  # Debug
ddx = 0.0  # Debug
ddy = 0.0  # Debug
Lhat = 1.05  # Debug



dt = 1.0/30.0

previous_time = time.time()

def callback(msg):

    global previous_time
    global hat_Pk
    global hat_thetak
    global q1

    points = np.array(msg.data).reshape(-1, 2)
    if not np.isnan(points).any():
        center01, center02, center11, center12, center21, center22 = points

        # Find direction vector of a line through the spheres,
        # given in camera coordinates

        Lc0 = find_line(center01, center02,
                        center11, center12,
                        center21, center22,
                        P0, P1, P2)


        # Find direction vector of a line through the spheres,
        # given in inertial coordinates
        q1 = -1.0 * q1
        Lvec = np.dot(np.array([[-np.cos(q1), 0,  np.sin(q1)],
                                [np.sin(q1),  0,   np.cos(q1)],
                                [0,          1.0, 0]]), Lc0)


        # Lvec = np.dot(np.array([[np.cos(q1), -np.sin(q1), 0], 
        #                         [0.0, 0.0, -1.0], 
        #                         [np.sin(q1), np.cos(q1), 0.0]]), Lc0)

        if np.linalg.norm(Lvec) > 0.00001:
            Lvec = Lvec / np.linalg.norm(Lvec)


        current_time = time.time()
        dt = current_time - previous_time
        previous_time = current_time

        # rospy.loginfo(1.0 / dt)

        hat_thetak, hat_Pk, zk = ekf(Lvec, np.array(
            [ddx, ddy]), hat_Pk, hat_thetak, q1, Lhat, dt)

        th, phi, dth, dphi, _, _ = hat_thetak
        msg = JointState()
        msg.header.stamp = rospy.Time.now()
        msg.name = ['phix_joint', 'phiy_joint']
        msg.position = [th, phi, zk[0], zk[1]]
        msg.velocity = [dth, dphi, 0.0, 0.0]
        msg.effort = [zk[0], zk[1]]

        pendulum_pub.publish(msg)

def joint_state_callback(msg):
    global q1
    q1 = msg.position[0]

def command_callback(msg):
    global ddx
    global ddy
    ddx = msg.gx
    ddy = msg.gy
    
def main():
    rospy.init_node('crane_vision_node')

    points_sub = rospy.Subscriber('/crane_vision_nodelet/points', Float64MultiArray, callback)
    joint_state_sub = rospy.Subscriber('/crane_state_controller/joint_states', JointState, joint_state_callback)
    commanded_sub = rospy.Subscriber(
        '/lyapunov_pendulum_damping_controller/commanded', CraneControl, callback=command_callback)

    rospy.spin()

if __name__ == "__main__":
    main()
